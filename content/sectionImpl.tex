\section{Umsetzung in Code}
Im Folgenden werde ich auf die Implementierung der einzelnen Module Schritt für Schritt eingehen und die Besonderheiten, Erfahrungen und Probleme während der Programmierung beschreiben. Ich werde argumentieren, warum ich etwas auf diese Art und Weise programmiert habe und was ich mir bei der Umsetzung gedacht habe. Um die PDF Web App auch offline nutzen zu können, habe ich die Library-Dateien runtergeladen und in einem Ordner libs direkt eingebunden, anstatt \gls{cdn}-Links zu den jeweiligen Libraries zu verknüpfen. Zur Positionierung von HTML-Elementen in der PDF Web App habe ich hauptsächlich auf das CSS Flexible Box (Flex Box) Layout zurückgegriffen. 

\subsection{Werkzeuge}
\begin{itemize}
	\item Entwicklungsumgebung: Visual Studio Code
	\item ausführende Programme: Browser Firefox, Opera, Google Chrome, Microsoft Edge
	\item Sprachen: JavaScript, CSS, HTML
	\item Libraries: Vue JS 3 Version 3.0.2, PDF-LIB, pdf.js, zip,js, Bootstrap Filestyle Version 2.1.0, Bootstrap Version 4.3.1, jQuery Version 3.6.0, Alwan
	\item Tutorials: Tiddly Wiki über die Bedienung der PDF Web App
\end{itemize}

\subsection{Links der Resources}
\begin{itemize}
	\item \url{https://vuejs.org/}
	\item \url{https://pdf-lib.js.org/}
	\item \url{https://github.com/mozilla/pdf.js}
	\item \url{https://github.com/gildas-lormeau/zip.js/}
	\item \url{https://github.com/markusslima/bootstrap-filestyle}
	\item \url{https://getbootstrap.com/}
	\item \url{https://jquery.com/}
	\item \url{https://github.com/SofianChouaib/alwan}
	\item \url{https://tiddlywiki.com/}
\end{itemize}

\subsection{Ordnerstruktur}
Abbildung \ref{fig:folders} stellt die Ordnerstruktur des Projekts dar. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.3\textwidth]{"images/folders.png"}
	\caption{Ordnerstruktur der PDF Web App}
	\label{fig:folders}
\end{figure}

Im Ordner js sind meine selbst geschriebenen JavaScript-Dateien und im Ordner css meine eigenen CSS-Dateien abgelegt. Genauso wurden alle HTML-Dateien von mir erstellt. Der Ordner libs enthält alle JavaScript- und CSS-Dateien von externen Libraries. Die Datei pdf.worker.min.js ist eine dependency von pdf.js und fontkit.umd.min.js gehört zur Library PDF-LIB, um benutzerdefinierte Fonts einzubinden. Im Prinzip hat jedes Modul seine eigene JavaScript-Datei. Das Script input\_control\_script.js, welches alle Module implementiert, enthält Kontrollfunktionen für Benutzereingabefelder und die ZIP-Download-Funktionen. Der Editor enthält teilt sich die Dateien pdf\_reader\_script.js und index\_reader\_style.css mit dem Reader. Die CSS-Datei widget\_style.css deckt den Creator, Merger und Splitter ab. Der Editor besteht aus mehreren Scripten: write\_pdf\_script.js für Textelemente, draw\_pdf\_script.js für Zeichnungen, geometry\_pdf\_script.js für Shapeelemente, images\_pdf\_script.js für Bildelemente, layer\_buttons\_script.js für Ebenenmenübuttons, select\_all\_script.js für die Auswahlfilterbuttons Select All und Deselect All und stack\_layers\_script.js für Ebenenmanagementfunktionen. 


\subsection{Umsetzung der Hauptmenüführung}
Das Hauptmenü wollte ich sehr simpel und minimalistisch gestalten. Daher habe ich für die Startseite nur einen weißen Hintergrund mit einem oberen Balken in der Farbe \#333, der die Hauptmenübuttons hervorhebt. Die Buttons haben einen vordefinierten Style von der Library Bootstrap. In der Bootstrap Library kann man den Style durch bestimmte Klassen auswählen. Nicht ausgewählte Buttons haben die Bootstrap-Klasse btn-success für die grünen Buttons und der ausgewählte dunkle Button mit grüner Schrift und Umrandung hat die Bootstrap Klasse btn-outline-success. Anfangs war es schwierig den default Style des input type="file" HTML-Elements zu verändern. Vor allem die Beschriftung des Buttons für Choose file war standardmäßig in Deutsch gehalten und lies sich nicht in englischer Sprache programmieren. Daher habe ich die Library Bootstrap Filestyle verwendet, um den Choose file Button in Englisch und mit anderem Style zu versehen. Da haben sich die Bootstrap Button Styles angeboten. Um eine Designkonsistenz zu erzielen, habe ich die Bootstrap Buttons überall in der PDF Web App in verschiedenen Stylevarianten verwendet. Lediglich beim Tools Seitenmenü im Editor habe ich einen eigenen Style für die Buttons für Elementoperationen programmiert. Der Reader, Splitter und Merger bestehen aus einer separaten HTML-Seite. Das Editormodul ist eine einzelne HTML-Seite, bei der je nach Funktion die entsprechenden Schaltflächen für die Elementoperationen mit display: flex eingeblendet und mit display: none ausgeblendet werden. 


\subsection{Implementierung des Readers}
Die Funktion für den Choose file Button ist im folgenden Codeabschnitt \ref{code:file} dargestellt:

\begin{lstlisting}[style=ES6, caption={Einlesen einer PDF-Datei}, label=code:file]
	let inputFileButtons = document.getElementsByClassName('inputfile');
	for (let i = 0; i < inputFileButtons.length; i++) {
		inputFileButtons[i].addEventListener("change", function(e) {
			resetAllModes();
			cleanUp();
			const encryptedErrorWidgets = 
				document.getElementsByClassName("encrypted_error");
			const noPDFErrorWidgets = 
				document.getElementsByClassName("no_pdf_error");
			file = e.target.files[0];
			const fileReader = new FileReader(); 
			fileReader.onload = function() {
				const typedarray = new Uint8Array(this.result);
				pdfState.originalPDFBytes = typedarray;
				const loadingTask = pdfjsLib.getDocument(typedarray);
				loadingTask.promise.then(async (pdf) => {
					let pdfDoc;
					try {
						pdfDoc = 
							await PDFLib.PDFDocument.load(pdfState.originalPDFBytes);
					} catch(encryptedErr) {
						encrypted = true;
					}
					if (!encrypted) {
						if (file.name.endsWith(".pdf")) {
							// ...
							pdfState.pdf = pdf;
							onetimeSetup = true;
							pdfFileName = file.name;
							// ...
							adjustPDFToUserViewport(pdfDoc);
							// ...
							renderPage(pageCounter, false);
						}
					} else {
						for (let i = 0; i < encryptedErrorWidgets.length; i++) {
							encryptedErrorWidgets[i].style.display = "flex";
						}
					}
				}).catch(unsupportedFileErr => {
					for (let i = 0; i < noPDFErrorWidgets.length; i++) {
						noPDFErrorWidgets[i].style.display = "flex";
					}
				});
			}
			if (file) {
				fileLoaded = true;
				fileReader.readAsArrayBuffer(file);
			}
		}, false);
	}
\end{lstlisting} 

Bei jedem Klick des Choose File Buttons werden alle Modi für aktive Buttons des Editors und andere Steuerungsmodi in der Funktion resetAllModes auf false gesetzt. Die Funktion cleanUp initialisiert globale Variablen auf ihre Standardwerte und globale Arrays werden leer angelegt. Ich lese die Datei mit einem FileReader Objekt ein und führe beim load Event eine Funktion aus, die das result als Uint8Array im Objektattribut originalPDFBytes des Objekts pdfState speichert. Die Funktionen fürs Laden, Erstellen und Speichern des PDFs der PDF-LIB erwarten und geben eine Uint8Array aus. Das Objekt für den Status des eingelesenen PDFs ist wie in Abbildung \ref{code:pdfstate} aufgebaut:

\begin{lstlisting}[style=ES6, caption={Objekt für ein geöffnetes PDF-Dokument}, label=code:pdfstate]
	let pdfState = {
		pdf: null,
		currentPage: 1,
		lastPage: 1,
		renderedPage: 0,
		zoom: 1,
		originalPDFBytes: null,
		existingPDFBytes: null,
		originalWidths: [],
		originalHeights: []
	}
\end{lstlisting} 

Eine loadingTask wird durch die pdf.js Funktion getDocument erzeugt, die ein pdf als Return-Wert des Promise zurückliefert. Falls die geöffnete Datei keine PDF-Datei war wird ein Fehler zurückgegeben. In der Fehlerbehandlung wird das Fenster, was die Fehlerinformation erhält sichtbar gemacht. Nach der Ausführung der loadingTask wird eine asynchrone Funktion aufgerufen, falls der Return Wert der loadingTask ein erfolgreiches promise zurückliefert. Hier wird der Reader initialisiert, die Reader Schaltflächen sichtbar gemacht und die Seiten gerendert. Zuerst wird das PDF Dokument mit den originalPDFBytes als Input mit einer PDF-LIB Ladefunktion geladen, um festzustellen, ob es sich um ein verschlüsseltes Dokument handelt. Wenn ja wird der Fehler geworfen und von mir abgefangen. In der Fehlerbehandlung wird eine globale Variable encrypted auf true gesetzt und das entsprechende Fehlerinformationsfenster angeschaltet. Nur wenn encrypted false ist und die Dateiendung .pdf besitzt, werden weitere Schritte eingeleitet. Zunächst werden die Fehlerinformationsfenster ausgeschaltet und im Attribut pdf des pdfState Objekts der erfolgreiche Return-Wert der loadingTask gespeichert. Dieses Objekt wird für das Rendern der PDF-Seiten im Reader benötigt. Dann wird das unbearbeitete PDF-Dokument nochmals in originalPDFBytes und existingPDFBytes gespeichert. Darauffolgend die Reader GUI aufgebaut und das PDF wird dem Viewport des Browsers angepasst. Zum Schluss wird der Rendervorgang durch die rekursive Funktion renderPage in Gang gesetzt.
\par
Die Funktion renderPage ist in Abbildung \ref{code:render} gezeigt.

\begin{lstlisting}[style=ES6, caption={Renderfunktion}, label=code:render]
	function renderPage(num, renderSingle) {
		pdfState.pdf.getPage(num).then(function(page) {
			let viewport = page.getViewport({
				scale: pdfState.zoom
			});
			let viewportOriginal = page.getViewport({
				scale: 1
			});
			let canvas;
			let div;
			const pdfViewers = document.getElementsByClassName("pdf_viewer");
			for (let i = 0; i < pdfViewers.length; i++) {
				const pdfViewer = pdfViewers[i];
				if (viewport.width > parseInt(pdfViewer.style.width, 10)) {
					pdfViewer.style.width = viewport.width + "px";
				}
				if (writeLayerStack.length < pdfState.pdf._pdfInfo.numPages) {
					div = document.createElement("div");
					div.style.display = "flex";
					div.width = viewport.width;
					div.height = viewport.height;
					div.style.width = viewport.width + "px";
					div.style.height = viewport.height + "px";
					div.style.marginBottom = "20px";
					pdfState.originalWidths.push(viewportOriginal.width);
					pdfState.originalHeights.push(viewportOriginal.height);
					div.setAttribute('data-write', pageCounter);
					div.classList.add("write_layer");
					canvas = document.createElement("canvas");
					canvas.style.display = "flex";
					canvas.style.width = viewport.width + "px";
					canvas.style.width = viewport.height + "px";
					canvas.width = viewport.width;
					canvas.height = viewport.height;
					canvas.setAttribute('data-page', pageCounter);
					canvas.classList.add("render_context");
					div.appendChild(canvas);
					pdfViewer.appendChild(div);
					writeLayerStack.push(div);
				} else if (writeLayerStack.length === 
					pdfState.pdf._pdfInfo.numPages) {
					if (!renderSingle) {
						div = writeLayerStack[pageCounter-1];
						canvas = writeLayerStack[pageCounter-1].childNodes[0];
					} else {
						div = writeLayerStack[num-1];
						canvas = writeLayerStack[num-1].childNodes[0];
					}
					div.width = viewport.width;
					div.height = viewport.height;
					div.style.width = viewport.width + "px";
					div.style.height = viewport.height + "px";
					canvas.width = viewport.width;
					canvas.height = viewport.height;
					canvas.style.width = viewport.width + "px";
					canvas.style.height = viewport.height + "px";
				}
			}
			const context = canvas.getContext('2d');
			let renderTask = page.render({
				canvasContext: context,
				viewport: viewport
			});
			if (!renderSingle) {
				renderTask.promise.then(function() {
					pdfState.renderedPage = pageCounter;
					restrictInputValues('current_page', 1, pdfState.renderedPage, 
						true, false);
					const pageProgresses = 
						document.getElementsByClassName("page_progress");
					for (let i = 0; i < pageProgresses.length; i++) {
						pageProgresses[i].innerText = `${pdfState.renderedPage}`;
					}
					pageCounter++;
					if (pageCounter > pdfState.lastPage) {
						const renderWidgetCons = 
							document.getElementsByClassName("render_widget_con");
						for (let i = 0; i < renderWidgetCons.length; i++) {
							renderWidgetCons[i].style.display = "none";
						}
						const renderWidgets = 
							document.getElementsByClassName("render_widget");
						for (let i = 0; i < renderWidgets.length; i++) {
							renderWidgets[i].style.display = "none";
						}
					} 
					if (pdfState.pdf != null && pageCounter <= pdfState.pdf._pdfInfo.numPages) {
						renderPage(pageCounter, false);
					}
				});
			}
		});
	}
\end{lstlisting} 

Die Funktion ruft sich rekursiv auf, falls noch nicht alle Seiten gerendert wurden und wird erst bei der letzten Seite verlassen. Sie kann für das Rendern von 1 Seite oder vielen Seiten verwendet werden. Beim Rotieren von Seiten um jeweils 90 Grad wird renderPage mit renderSingle=true verwendet, damit nur die gedrehte Seite neu gerendet wird. Mittels des pdfState.pdf Objekts wird die aktuelle Seite geholt und ein Promise mit einem page Objekt wird zurückgegeben. Danach wird eine umfangreiche anonyme Funktion aufgerufen. Bei allen Zoomfunktionalitäten, wie der Plus Button zum Reinzoomen wird renderPage mit einem anderen Zoomfaktor, als dem initialen Zoomfaktor von 1 aufgerufen. Das pdfState property zoom speichert den aktuellen zoom Faktor des PDF-Dokuments und wird in scale vom viewport der aktuell zu rendernden Seite gespeichert. Die viewport Variable gibt dann Auskunft über die Breite und Höhe der tatsächlichen Seite mit diesem scale Faktor. Außerdem wird ein weiterer viewport, hier viewportOriginal genannt, mit dem Skalierungsfaktor von 1 gespeichert. Die width und height von viewportOriginal wird pro Seite dem originalWidths und originalHeights Array properties von pdfState hinzugefügt.