\subsection{PDFex PDF Encryption Attacks}
PDFex bezeichnet Attacken auf die PDF-Verschlüsselung mit Passwortschutz, die im Jahr 2019 entdeckt wurden. Die Forscher haben 27 PDF-Viewer auf diese Attacken getestet und alle Viewer inklusive Adobe Reader, Chrome and Firefox waren mindestens für eine Attacke anfällig. Es gibt 2 Attack-Klassifizierungen: Direct Exfiltration und \gls{cbc} Malleability Gadgets.
Das attacker model gestaltet sich wie folgt: 2 Personen Alice und Bob wollen ein vertrauliches PDF mit Passwortschutz austauschen. Wir nehmen an, dass ein Angreifer durch eine \gls{mitm} attack das verschlüsselte PDF unbemerkt abgreifen konnte als Alice das Dokument zu Bob geschickt hat. Daraufhin modifiziert der Angreifer das Dokument, sodass die Veränderungen unerkennbar sind für Bob, und schickt seine Version des Dokuments an Bob. Bob entsperrt das Dokument mit seinem Passwort und das entschlüsselte PDF wird automatisch zurück zum Server des Angreifers übertragen. \cite{ccc-break-pdf, pdfex}
\par
Ein verschlüsseltes PDF enthält einen Objekt-Stream als verschlüsselten ciphertext im Body und einen /Encrypt entry, der Informationen darüber enthält, wie die Daten entschlüsselt werden sollen. Der Großteil der PDF-Dateistruktur liegt unverschlüsselt vor. Ausschließlich alle Strings und Streams für Inhalte ohne die anderen Objekttypen wie Integer oder Booleans, die dokumentstrukturbeschreibend sind, werden verschlüsselt. Der Grund dafür ist, dass die PDF-Spezifikation weiterhin die random-access Optimierung im Dateiformat beibehalten möchte. Folglich ist die gesamte Dokumentenstruktur unverschlüsselt und eine ganze Reihe an wichtigen Informationen wie Anzahl und Größe der Seiten, verwendete Objekte oder Hyperlinks können vom Angreifer ausgelesen werden. \\
PDF verwendet einen speziellen Streamfilter-Typ, genannt crypt filter für die Verschlüsselung. Jeder Standard-Filter eines Streams kann vom crypt filter überschrieben werden. Ein standard identity filter wird bei besonderen Streams für z.B. Dokumentmetadaten gesetzt, damit diese in einem verschlüsselten Dokument unverschlüsselt bleiben. Diese Unterstützung von partieller Verschlüsselung kann einem Angreifer ermöglichen seinen Inhalt mit verschlüsseltem zu vermischen ohne das Passwort zu wissen. Forscher fanden 18 verschiedene Angriffsvarianten für eine ganze Reihe von PDF-Readern. \cite{ccc-break-pdf}
\par
Bei der direct exfiltration attack wird die Kryptografie nicht angerührt. Bei allen Strings im verschlüsselten PDF von Alice überschreibt der Angreifer die crypt filter mit identity filter. Jetzt kann der Angreifer bei Bedarf Strings verändern und kann weitere Objekte mit unverschlüsselten Strings hinzufügen. Außerdem kann er verschlüsselte Teile des Dokuments in Inhalte einfügen, die er kontrolliert, d.h. er kann auf verschlüsselte Streams oder Strings in seinem Inhalt referenzieren und zugreifen. Nachfolgend fügt er eine submit-form action hinzu, die Namen und Werte von AcroForms zu einer Ziel-URL überträgt. Der Text des Formularfelds wird als Stream gespeichert. Kombiniert der Angreifer eine OpenAction, die ausgeführt wird, sobald das Dokument geöffnet wird, mit einer submit-form action zu attacker.com, so kann der vertrauliche entschlüsselte Inhalt an den Angreifer zurück als POST request gesendet werden. Die OpenAction wird ausgelöst, sobald Bob sein Passwort eingegeben hat. Statt einer sumbit-form action kann man auch einen Hyperlink verwenden. Jedes Objekt kann als Hyperlink definiert werden, was einen GET request zu attacker.com triggert. JavaScript kann ebenfalls verwendet werden. \cite{ccc-break-pdf, pdfex}
\par
PDF verschlüsselt durch \gls{aes}-256 mit einer Schlüssellänge von 256 Bit und operiert im \gls{cbc} mode ohne \gls{mac} Integritätsschutz. \gls{aes} gehört zu den Blockchiffren und ist ein symmetrisches Verschlüsselungsverfahren. Bei symmetrischer Verschlüsselung gibt es nur einen Schlüssel fürs Verschlüsseln und Entschlüsseln. Ein Block ist 128 Bit lang. Der subkey (Rundenschlüssel) hat immer eine Länge von 128 Bit. Die Schlüssellänge beeinflusst den key schedule, d.h. die Art und Weise wie Rundenschlüssel vom master key abgeleitet werden, sowie die Anzahl an Runden. Während der Algorithmus ausgeführt wird, wird ein 4 x 4 Array aus je 1 Byte (insgesamt 128 Bit), genannt state, in 14 Runden verschlüsselt. Im ersten einzigen Schritt, der KeyExpansion, werden die Rundenschlüssel für jede Runde plus 1 weiterer Rundenschlüssel aus dem master key berechnet. Anfangs wird der state gleichgesetzt mit dem der zu unverschlüsselten Nachricht (plaintext). Auf dem state Array wird bitweises XOR mit dem Rundenschlüssel im AddRoundKey-Schritt angewendet. Jedes Byte vom state wird dabei mit einem Byte vom Rundenschlüssel kombiniert. Im SubBytes (substitution) Schritt wird jedes Byte des aktualisierten state Arrays mit einem Byte durch eine Substitutionstabelle (S-Box) ersetzt. Dadurch werden die Bytes im state vermischt. Danach kommt die SchiftRows-Sequenz. Die Bytes in jeder Zeile von state werden unterschiedlich nach links verschoben: Die 1. Zeile bleibt unberührt, die 2. Zeile wird um 1 verschoben, die 3. um 2 und die letzte um 3 Positionen. Die überlaufenden Zellen werden rechts an die jeweilige Zeile wieder angehängt. Als Vorletztes jeder Runde außer der letzten Runde kommt MixColumn dran. Hier werden Spalten vermischt, indem jede Spalte mit einer konstanten Matrix zu einer neuen Spalte multipliziert wird. Abschließend zu jeder Runde wird nochmals AddRoundKey mit dem aktuellen Rundenschlüssel ausgeführt, also state bitweise XOR verknüpft mit dem Rundenschlüssel. Im letzten Schritt produziert AddRoundKey den ciphertext. Die invertierte Operation des Algorithmus wird beim entschlüsseln angewendet und alle Funktionen werden umgekehrt aufgerufen. \cite{intro-crypto, studyflix-aes, simply-aes} \\
Während des \gls{cbc} mode wird ein vorheriger ciphertext block mit dem nächsten plaintext block durch XOR verknüpft. Das Ergebnis und der Schlüssel dienen als Input für den \gls{aes}-Algorithmus und produzieren den verschlüsselten Output als ciphertext block. Im ersten Schritt wird der erste plaintext block mit einem Initialisierungsvektor IV (nonce) als Zufallszahl oder Zeitstempel mit XOR verknüpft. IV sollte nur einmal verwendet werden uns muss Sender und Empfänger bekannt sein. \cite{crypto-web} \\
Ein \gls{mac} ist eine kryptographische Prüfsumme, die aus dem Datensatz und dem symmetrischen Schlüssel von Sender und Empfänger gebildet wird. Im Gegensatz zu einem Hash kann der \gls{mac} nur von Sender und Empfänger berechnet und ebenfalls von beiden verifiziert werden. \cite{crypto-web}
\par
Nicht alle PDF-Viewer unterstützen teilweise verschlüsselte Dokumente. Solche Viewer sind immun gegen direct exfiltration attacks. Trotzdem können Angreifer \gls{cbc} malleability gadgets verwenden, um die Exfiltration des Texts zu erhalten, da keine \gls{mac} für den ciphertext beim PDF-Standard verwendet wird. Für die Ausführung der Attacke müssen 2 Vorbedingungen erfüllt sein: Zum einen muss ein plaintext-Segment dem Angreifer vorliegen. Beim aktuellsten \gls{aes}V3-Algorithmus kann der plaintext als 16 Bytes aus dem verschlüsselten /Perms entry (extended permissions) einer PDF-Datei abgeleitet werden. Die zweiten 4 Bytes sind die permissions /P, die unverschlüsselt im PDF-Dokument herausgelesen werden können. Das Byte aus T oder F wird entsprechend des EncryptMetadate Booleans gesetzt. Der /Perms entry wird mit dem gleichen Schlüssel für Streams und Strings verschlüsselt, daher kann man ihn verwendet um \gls{cbc} gadgets zu konstruieren. Obwohl der /Perms-Wert mit \gls{ecb} mode verschlüsselt wird, ist der output ciphertext gleich seinem plaintext, wenn man ihn mit \gls{cbc} verschlüsselt und dabei einen initialization vector von 0 verwendet würde. Bei älteren Versionen des \gls{aes}-Algorithmus in PDF muss der bekannte plaintext aus dem Objekt, auf das die Exfiltration angewendet werden soll, extrahiert werden. \cite{ccc-break-pdf, pdfex}
\par
Alice verschlüsselt eine Nachricht aus 2 Blöcken p0 und p1 zum initialization vector IV, c0 und c1 und Bob kann diese Nachricht wieder zu p0 und p1 entschlüsseln. \gls{cbc} gadgets kann man konstruieren mit einem bekannten plaintext von 16 Bytes p0 und kann dadurch neue plaintext blocks g0 und g1 in eine entschlüsselte plaintext message einfügen. Beispielsweise könnte g1 die URL vom Angreifer enthalten, sodass er sich die entschlüsselte Nachricht p1 von Bob zu seinem Server schicken lassen kann. Der Angreifer erhält die Nachricht aus IV, c0 und c1 von Alice durch eine \gls{mitm} attack und konstruiert 2 neue verschlüsselte ciphertext blocks x0 und x1. Nimmt man IV XOR p0 erhält man ausschließlich Nullen. X0 als vom Angreifer erstellter IV wird durch IV XOR p0 XOR g0 und x1 durch IV XOR p0 XOR g1 gebildet. Eine neue verschlüsselte Nachricht wird durch die concatenation von x0, c0, x1, c0 und c1 gebildet. Der ursprüngliche c0 Block wird 2 Mal verwendet. X0 ist der neue IV und x1 ist lediglich dazu da die Verkettung beizubehalten. X1 wird zu unkontrollierbaren Bytes ohne Sinn entschlüsselt. C1 ist der verschlüsselte Block von Alice, der die Zieldaten, enthält. Bei der Entschlüsselung erhält Bob den vom Angreifer erstellten plaintext block g0, die unkontrollierten Bytes, den zweiten plaintext block vom Angreifer g1 und die entschlüsselten Zieldaten von Alice. Folglich konnte der Angreifer Alices p0 durch g0 und g1 ersetzen. Als Exfiltration Channel kommen AcroForms oder Hyperlinks in Frage, um die entschlüsselte Nachricht von Bob zurück an den Angreifer zu schicken. \cite{gadget, pdf-insec-gadget, ccc-break-pdf}
\par
Hauptursache des Problems ist, dass viele Datenformate eine Teilverschlüsselung erlauben, z.B. \gls{xml}, S/\gls{mime} und PDF, was dem Angreifer ermöglicht eigene Inhalte einzuschleusen und exfiltration channels bilden zu können. Des Weiteren enthält \gls{aes}-\gls{cbc} keinen Integritätsschutz wie einen \gls{mac}, sogar nicht in PDF 2.0. Diese Sicherheitslücken sollten ohne Rückwärtskompatibilität in zukünftigen PDF-Spezifikationen entfernt werden. \cite{pdfex}
