\section{Umsetzung in Code}
Im Folgenden werde ich auf die Implementierung der einzelnen Module eingehen und die Besonderheiten, Erfahrungen und Probleme während der Programmierung beschreiben. Um die PDF Web App auch offline nutzen zu können, habe ich die Library-Dateien im Ordner libs direkt eingebunden, anstatt \gls{cdn}-Links zu den jeweiligen Libraries zu verknüpfen. Zur Positionierung von HTML-Elementen habe ich hauptsächlich auf das CSS Flexible Box (Flex Box) Layout zurückgegriffen. 

\subsection{Werkzeuge}
\begin{itemize}
	\item Entwicklungsumgebung: Visual Studio Code
	\item ausführende Programme: Firefox Browser
	\item Sprachen: JavaScript, CSS, HTML
	\item Libraries: Vue JS 3 Version 3.0.2, PDF-LIB (TypeScript), Fontkit zur Einbettung von benutzerdefinierten Fonts, pdf.js (TypeScript), zip,js, Bootstrap Filestyle Version 2.1.0, Bootstrap Version 4.3.1, jQuery Version 3.6.0 dependency von Filestyle, Alwan für den Color Picker
	\item Tutorials: Tiddly Wiki
\end{itemize}

\subsection{Links der Resources}
\begin{itemize}
	\item \url{https://vuejs.org/}
	\item \url{https://pdf-lib.js.org/}
	\item \url{https://www.npmjs.com/package/@pdf-lib/fontkit}
	\item \url{https://github.com/mozilla/pdf.js}
	\item \url{https://github.com/gildas-lormeau/zip.js/}
	\item \url{https://github.com/markusslima/bootstrap-filestyle}
	\item \url{https://getbootstrap.com/}
	\item \url{https://jquery.com/}
	\item \url{https://github.com/SofianChouaib/alwan}
	\item \url{https://tiddlywiki.com/}
\end{itemize}

\subsection{Ordnerstruktur}
Im root Ordner docs befinden sich 5 eigene HTML-Dateien, ein Ordner libs mit 12 JS und CSS Dateien von externen Libraries, ein Ordner css mit 3 von mir geschriebenen CSS-Dateien und ein Ordner js mit selbst erstellten JavaScript-Dateien. Die Datei pdf.worker.min.js ist eine dependency der pdf.js TypeScript-Library und fontkit.umd.min.js gehört zur TypeScript-Library PDF-LIB, um benutzerdefinierte Fonts einzubinden. Im Prinzip hat jedes Modul seine eigene JavaScript-Datei. Das Script input\_control\_script.js, welches global implementiert wird, enthält Kontrollfunktionen für Benutzereingabefelder (Input Control) und die ZIP-Download-Funktionen. Der Editor teilt sich die Dateien pdf\_reader\_script.js und index\_reader\_style.css mit dem Reader. Die CSS-Datei widget\_style.css deckt den Creator, Merger und Splitter ab. Der Editor besteht aus mehreren Scripten: write\_pdf\_script.js für Text, draw\_pdf\_script.js für Drawings, geometry\_pdf\_script.js für Shapes, images\_pdf\_script.js für Images, layer\_buttons\_script.js für das Layers Menu, select\_all\_script.js für die Selection and Deselection Filter Menus und stack\_layers\_script.js für Layers-Managementfunktionen. Reader, Splitter und Merger besitzen jeweils eine separaten HTML-Seite. Das Editormodul ist eine einzelne HTML-Seite, bei der je nach Funktion die entsprechenden Schaltflächen für die Elementoperationen mit display: flex eingeblendet und display: none ausgeblendet werden. 

\subsection{Layoutgestaltung}
Das Hauptmenü wollte ich minimalistisch, klar und übersichtlich gestalten. Daher habe ich für die Startseite lediglich einen weißen Hintergrund gewählt mit einem oberen Balken in der Farbe \#333 als dunkles Grau zur Hervorhebung der Hauptmenübuttons. Dasselbe dunkle Grau wiederholt sich in den beiden oberen Reader-Leisten und dem Reader-Hintergrund. Die Buttons haben einen vordefinierten Style von der Library Bootstrap. In der Bootstrap-Library kann der Style durch fixe Klassen bestimmt werden. Alle grünen Buttons und die selection menus im Creator und Splitter haben die Bootstrap-Klasse btn-success. Der dunkelgraue Button mit grüner Schrift und Umrandung des aktiven Hauptmenü-Buttons besitzt die Bootstrap-Klasse btn-outline-success. Die Beschriftung des Buttons für Choose file (INPUT type file HTML-Element) ist standardmäßig in Deutsch gehalten und lässt sich grundsätzlich nicht in englischer Sprache programmieren. Aus diesem Grund habe ich die Library Bootstrap Filestyle verwendet, um den Choose file-Button in Englisch zu beschriften. Um eine Designkonsistenz zu erzielen, habe ich die Bootstrap-Buttons flächendeckend in der GUI in verschiedenen Stylevarianten verwendet. Lediglich bei Tools im Editor habe ich einen eigenen Style für die Buttons der Elementoperationen programmiert. Diese weißen Buttons besitzen eine schwarze Schrift mit einer border-width von 2 Pixeln, einem border-radius von 5 Pixeln und einer border-color von \#333. 
\par
Der inaktive, weiße Modus-Button und die ausgeschalteten Selection und Deselection Filter in Layers sind mit dem Bootstrap-Style btn-light versehen. Alle dunkelgrauen Buttons wurden mit dem Bootstrap-Style btn-dark implementiert. Jegliche rosa Flächen und ausgewählte Layers haben die Farbe \#dabdb6. Der hellgraue Operations Bar und das Namensfeld einer Layer sind in \#8c8c8c (Hellgrau) gefärbt. Tools und aktivierte checkboxes haben eine Hintergrundfarbe in \#5eb873 (Türkis). Der Hintergrund von Layers, Layers Menu, sowie die Seitengruppen und Tools besitzen einen Alphawert von 0.8. Abgewählte Layers, selection menus in Tools, der Hintergrund beim Output-Dateinamen und ausgewählte Dateinamen im Merger sind schwarz. Alle Horizontal-Leisten mit Operationen haben eine Höhe von 58 Pixeln und dessen Buttons einen horizontalen Abstand von 5 Pixeln. Layers und Tools sind jeweils 190 Pixel breit. In Dateinamen von Font- und Bilddateien wird nach 15 Zeichen ein Zeilenumbruch eingefügt. Der Dateiname des Output-PDFs ist auf 50 Zeichen beschränkt. Im Reader befinden sich zwischen den gerenderten Seiten 20 Pixel Abstand. Alle input fields, Scrollbars und INPUT type checkbox HTML-Elemente besitzen den default Style des Browsers. Die default Dateinamen für Reader und Editor sind wie folgt benannt: Source Dokument Dateiname, ein Unterstrich und edited. Der Creator benennt standardmäßig die Output-Datei mit blank\_pdf und der Merger mit merged\_pdf. Im Splitter wird als Dateibenennungsschema der source Dateiname, ein Unterstrich und split verwendet. 

\subsection{Input Control}
Eine automatisierte Eingabekontrolle von Benutzereingabefeldern findet in allen Modulen außer dem Merger statt. Alle input fields sind INPUT type text HTML-Elemente, anstatt type number – selbst wenn nur Zahlen als Eingabewerte gültig sind. Das hat folgenden Hintergrund: Es gibt eine Funktion restrictInputValues, die automatisch Benutzereingaben korrigiert. Die Funktion wird ausgelöst, sobald das input field verändert wurde (change event). Im Prozess wird der event handler zunächst entfernt, bevor er angeheftet wird. Würde der event handler nicht initial abgekoppelt werden, würde dieses Eingabefeld immer mehr event handler akkumulieren. RestrictInputValues entfernt jeglichen white space, wandelt die Benutzereingaben als String in Zahlen um und hält die eingegebenen Werte in einem gültigen Wertebereich. Außerdem habe ich eine Funktion convertInputToSuccess programmiert, die den Input-String in einen Zahlenwert parst und den geparsten Wert oder -1000 (invalid input) zurückgibt. Die return value von convertInputToSuccess bestimmt maßgeblich, ob Operationen, z.B. die Font Size im Writer, ausgeführt werden sollen. Für die Eingabe einer Seitenliste, existiert eine gesonderte Funktion convertPagelistToSuccess. An dieser Stelle wird bei invalid input die Benutzereingabe zurückgesetzt. Eine genauere Beschreibung des Verhaltens der Input Control werde ich im Unterkapitel Testdurchführung, Abschnitt Testauswertung, weiter ausführen.

\subsection{Einlesen einer PDF-Datei im Reader und Editor}
Bei jedem Klick auf den Choose File-Button werden alle Modi für aktive Operation-Buttons des Editors und andere Steuerungsmodi in der Funktion resetAllModes auf false gesetzt. Die Datei wird mittels eines FileReader-Objekts eingelesen und dem load event wird eine anonyme Funktion zugewiesen. Die eingelesene PDF-Datei, bestehend aus einem Uint8Array, wird in den properties originalPDFBytes und existingPDFBytes des globalen Objekts pdfState gespeichert. PdfState repräsentiert den aktuellen Anzeige- und Datenstatus des eingelesenen PDFs repräsentiert. Die PDF-LIB-Funktionen für das Erzeugen und Laden eines PDFs akzeptieren einen Parameter vom Typ Uint8Array. Ihre Return-Werte geben ein Promise-Objekt zurück, was ein PDFDocument Objekt der PDF-LIB im resolve-Fall liefert. Die PDF-LIB-Speicherfunktion gibt ein als Uint8Array serialisiertes PDF zurück. Im Editor wird bei jedem Downloadvorgang des modifizierten PDFs das originale PDF als Grundlage zur Einbettung verwendet (originalPDFBytes).
\par
Eine loadingTask wird durch die pdf.js-Funktion getDocument erzeugt, die ein libraryinternes pdf Objekt zurückliefert. Dieser Return-Wert wird in pdfState.pdf abgelegt. In pdfState.lastPage wird die Seitenzahl der letzten Seite gespeichert. Das pdf.js-eigene pdf-Objekt wird für das Rendern der PDF-Seiten im Reader und Editor benötigt. Weiter in der anonymen Funktion wird das PDF dem Viewport des Browsers mit einem horizontalen Abstand von 100 Pixeln pro Fensterseite angepasst. Anschließend wird pdfState.renderedPage initialisiert. Dieses property enthält die aktuell gerenderte Seite, die am Ende des Rendervorgangs der letzten Seite des PDFs entspricht. Ob es sich um den Reader oder Editor handelt, wird überprüft, indem die Bootstrap-Klassen der zugehörigen Hauptmenü-Buttons abgefragt werden. Falls der Editor geöffnet wurde, wird er mit einer Zeitverzögerung von 300 ms aufgebaut. Hintergrund dessen ist, dass die vorherige \gls{dom}-Version erst gerendert werden muss, sonst ergibt sich bei Zugriff auf HTML-Collections – ein arrayähnliches Objekt – eine Length von 0. Am Ende wird der Rendervorgang durch die rekursive, asynchrone Funktion renderPage in Gang gesetzt. Das \gls{dom} ist eine Web API für Webdokumente wie HTML-Dokumente. Es repräsentiert die Webseite als nodes und Objekte, sodass Programmiersprachen die Dokumentenstruktur, -style und -inhalt modulieren können. Strukturell besteht das \gls{dom} aus dem \gls{dom} tree, dessen nodes den HTML-Inhalt repräsentieren. Im \gls{dom} sind alle properties, Methoden und events für die Manipulation und Erzeugung von Webseiten als Objekte organisiert \cite{mozilla-dom}. Das property currentPage von pdfState beinhaltet die aktuelle Seite, die im Viewport angezeigt wird. Es wird auch bei der Navigation zu Seiten angepasst.

\subsection{Renderfunktion}
Die Funktion renderPage ruft sich für alle noch nicht gerenderten Seiten rekursiv auf. Sie kann den Rendervorgang für eine oder alle Seiten vornehmen. Eine einzelne Seite wird neu gerendert, sobald sie im Reader gedreht wurde. Pro Funktionsaufruf wird der globale pageCounter hochgezählt. Mittels des pdfState.pdf-Objekts wird die aktuelle Seite geholt und ein Seitenobjekt von pdf.js entgegengenommen. Aus diesem Seitenobjekt wird der Viewport der Seite extrahiert und eine Skalierung festgelegt. PdfState.zoom, welches die aktuelle Skalierung des gesamten PDF-Dokuments angibt, wird der Viewport-Skalierung zugewiesen. Viewport besitzt width und height properties. Zusätzlich wird der Viewport mit einer Skalierung von 1 gespeichert. Hintergrund dessen ist, dass im weiteren Verlauf von renderPage die Arrays pdfState.originalWidths und pdfState.originalHeights die Originalgrößen jeder Seite aufnehmen sollen. Der Container des gerenderten PDFs besteht aus mehreren verschachtelten DIV-HTML-Elementen, wobei das innere Element die Klasse pdf\_viewer besitzt. Dem inneren pdf\_viewer-Container werden pro Ausführung von renderPage ein DIV mit der Klasse write\_layer und ein Attribut data-write, was die zugehörige Seitenzahl speichert, hinzugefügt. Die write\_layer symbolisiert einen Seitencontainer, der die gerenderte PDF-Seite und beigefügten Elemente des Editors enthält. Die gerenderte PDF-Seite wird in einem CANVAS-HTML-Element als erstes child der write\_layer dargestellt. Diese CANVAS hat die Klasse render\_context und ein Attribut data-page für die identische Seitenzahl der write\_layer. Sowohl die write\_layer als auch der render\_context werden in der Größe des aktuell skalierten Viewports angelegt. Die write\_layers werden zusätzlich in einem Array writeLayerStack gesammelt. WriteLayerStack hält die write\_layers in der Reihenfolge der PDF-Seiten im Dokument. Während eines erneuten Rendervorgangs wird der render\_context wiederverwendet. Anschließend wird mittels der pdf.js-Library die Seite gerendert. Nach Beendigung der renderTask wird eine anonyme Funktion ausgeführt. Die pageCounter-Variable wird pdfState.renderedPage zugewiesen. Dieses property wird als Maximalwert für die Input Control bei der Navigation zu einer bestimmten Seite verwendet.

\subsection{Implementierung der Vue JS 3-Module}
Die Module Creator, Splitter und Merger verwenden das Framework Vue JS 3, zwar nicht in nativer Form als \gls{spa}, sondern als stand-alone widgets. Im Creator wird annähernd die eingestellte PDF-Seitengröße als Breite und Höhe der MediaBox durch die Berechnung Seitenlänge * 1000 / 352,8 gesetzt. Diese Berechnung habe ich durch Tests erarbeitet. Durch Anwählen der Portrait-Orientierung wird in den Width and Height input fields der kleinere Wert der Seitendimensionen für die Width gesetzt und der größere Wert für die Height. Im Falle von Landscape werden Width und Height vertauscht. Quadratic orientiert sich an der Width.
\par
Nach Aufruf des Splitters wird zunächst ein gesperrter Save-Button vorgefunden. Die Benutzbarkeit des Save-Buttons wird erst freigeschaltet, nachdem eine Datei und Split-Methode im selection menu ausgewählt wurde. Unter dem Choose file-Button ist der auf 50 Zeichen gekürzte Dateiname abgebildet. Erst wenn list of pages selektiert wurde, wird das input field für die Seitenliste aktiviert. Die Split-Funktion für gerade und ungerade Seiten nennt sich splitAfter. Basierend auf den Rest Modulo 2 wird die Funktion mit der Bedingung ausgeführt, dass bei der even pages-Split-Methode mehr als 3 Seiten bzw. bei der odd pages-Split-Methode mehr als 2 Seiten im Input-PDF vorhanden sind. Andernfalls bleibt der Save-Button deaktiviert. Die Input-PDF-Bestandteile als PDFDocument Objekte, die nach jedem Split-Vorgang bei der PDF-LIB-Funktion PDFDocument.create entstehen, werden in einem globalen Array splittedPDFs gesichert. Die Arraybestandteile werden einzeln durch Klick auf Save zu einem Uint8Array serialisiert und in einem globalen Array pdfBytesList gespeichert. PdfBytesList wird letztendlich der compressMultipleToZip-Funktion übergeben. Jedes gesplittete PDF erhält den Ursprungsdateinamen, einen Unterstrich und einen Index beginnend mit 0, der das Teil-PDF aufsteigend in der Split-Reihenfolge nummeriert. Alle PDF-Bestandteile werden als ZIP-Ordner verpackt. Am Ende des Downloads werden splittedPDFs und pdfBytesList als leere Arrays erneut initialisiert.
\par
Im Merger wird eine geöffnete Datei als Uint8Array einem globalen Array selectedPDFBytes hinzugefügt. Zusätzlich wird einem UL-HTML-Element, dem Dateilistencontainer, pro Datei ein LI-HTML-Element mit der Klasse file\_unselected angehängt. Außerdem wird der auf 50 Zeichen gekürzte Dateinamen und ein click event handler für die Dateimarkierung hinzugefügt. Sind mehr als eine oder maximal 100 Dateien ausgewählt, schalten sich Save und Remove ein. Außerdem wird der LI eine Reihe an drag events hinzugefügt: Dragstart, dragover und drop. Funktion der drag events ist, dass die Listeneinträge in ihrer Reihenfolge alterniert werden können. Zu jedem Zeitpunkt spiegelt das Array selectedPDFBytes die Reihenfolge der Listeneinträge wieder. Für das dragging muss der Listeneintrag nicht markiert sein, jedoch beim Entfernen von einzelnen Listeneinträgen. Ist ein Listeneintrag schwarz markiert, wird die Klasse file\_unselected mit der Klasse file\_selected des entsprechenden LI ersetzt.

\subsection{Struktur der Editorelemente}
Die 4 Editorelemente Text, Drawing, Shape und Image werden bei Erzeugung auf der Seite in globalen Arrays als Elementlisten in Erstellungsreihenfolge abgelegt: userTextList für Text, drawLayerStack für Drawings, geometryPointsList für Shapes und userImageList für Images. Zur Erstellung der Editorelemente verwende ich zum einen Objekte, welche die Nodestruktur der Elemente in der Webseite abbilden. Zum anderen setze ich Objekte ein, die die elementspezifischen Eigenschaften repräsentieren. Genannte Objekte erben von Prototyp-Objekten gemäß dem Konzept der prototypischen Objektorientierung. Das strukturelle Prototyp-Objekt für Text, Drawing und Image heißt controlPoint und das strukturelle Prototyp-Objekt für Shape nennt sich shapeControllerPoint.
\par
Vom controlPoint-Prototyp leitet das Objekt controlP ab und von shapeControllerPoint erbt shapeControllerP. ShapeControllerPoint stellt einen spezialisierten controlPoint dar, der mit Rotations-properties und einer Rotations-Methode erweitert wurde. Da sich Text, Drawings und Shapes den controlPoint-Prototyp teilen, enthält er ein property type, was den Elementtyp als String speichert. ControlP- und shapeControllerP-Objekte werden direkt in userTextList, drawLayerStack, userImageList und geometryPointsList gespeichert. Die Prototypen besitzen ein property elementToControl, um die Objekte mit elementspezifischen Eigenschaften zu referenzieren. Dessen Prototypen heißen userText für Text, drawLayer für Drawings, shape für Shapes und userImage für Images. Die spezifischen Objekte zu ihren Prototypen nennen sich currentUserText für userText, drawingLayer für drawLayer, currentShape für shape und currentUserImage für userImage. Sowohl die Nodestruktur- als auch die Eigenschaftsobjekte werden durch Hinzufügen von Elementen auf der Seite erstellt und mit Standardwerten initialisiert. 

\subsection{Aufbau eines PDF-Seitencontainers}
Die Wurzel eines PDF-Seitencontainers bildet ein DIV mit der Klasse write\_layer. Write\_layer hat mindestens ein child und eine CANVAS mit der Klasse render\_context. Dieser Fall liegt vor, wenn noch keine Elemente der Seite hinzugefügt wurden. Der render\_context lässt sich als Zeichenfläche vorstellen, die durch die Dimensionen der Seite begrenzt ist. Er enthält die gerenderte Seite als Hintergrund für Elementoperationen. Sobald Elemente auf der Seite ergänzt wurden, stapeln sich weitere Schichten auf dem render\_context. Ein Editorelement setzt sich zusammen, aus einer CANVAS (editimg) für die Darstellung und einem 40 x 40 Pixel-großen DIV (controlBox) für den Kontrollpunkt des Elements. Die CANVAS besitzt 3 Klassen: Editimg, visible und eine Elementtyp-Klasse. Die Klasse editimg konkretisiert die CANVAS, die das gerenderte, einzelne Element enthält. Visible definiert den Sichtbarkeitsstatus über die Ebenensteuerung in Layers. Die Typklasse kann entweder text, drawing, shape oder image sein. Jedes editimg enthält zudem die Attribute data-page für die Seitenzahl und data-index für die Position in der Elementliste. Die Größe des editimgs entspricht immer der Größe des zugehörigen render\_context. Auf der controlBox habe ich eine Reihe von event handler definiert, die die Operationen im Operations Bar und in Tools ausführen. Sie besitzt eine Typklasse und die Klasse box, um alle controlBoxes im Dokument ansprechen zu können. Die controlBox ist ebenfalls mit den gleichen data-Attributen wie das zugehörige editimg ausgestattet. Bei Erzeugung wird das zuletzt erstellte editimg oberhalb des Stapels positioniert. Alle editimgs werden in einem Gruppierungs-DIV mit der Klasse editimg\_group akkumuliert. Ebenfalls werden alle controlBoxes in einem gruppierenden DIV mit der Klasse control\_group vereint. Die editimg\_group liegt über dem render\_context im node tree Segment. Ganz oben befindet sich die control\_group, damit controlBoxes nicht von gerenderten Elementen verdeckt werden. Die control\_group und editimg\_group werden beim Hinzufügen des ersten Elementes auf der Seite erstellt. Jede write\_layer hat jeweils eine editimg\_group und control\_group. Das node tree Segment für den Aufbau einer write\_layer ist in Screenshot \ref{fig:write-layer} veranschaulicht. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{"images/write-layer.png"}
	\caption{Node-Tree Segment für den Aufbau einer write\_layer mit 4 Elementen jedes Typs}
	\label{fig:write-layer}
\end{figure}

Für editimg und controlBox existieren gleichnamige properties in den Nodestrukturobjekten. Dort wird die CANVAS und das DIV abgespeichert. Außerdem gibt es ein layer property, in dem die zugehörige write\_layer gesichert ist. In den properties type wird der Elementtyp als String hinterlegt, page beschreibt die Seitenzahl, x und y sind die Koordinaten auf der Seite und index ist die Position des Elements in der zugehörigen Elementliste. Die Reihenfolge der Elemente in userTextList, drawLayerStack, geometryPointsList und userImageList ändert sich nie, es sei denn, ein Element wird von der Seite entfernt. Sowohl der index als auch data-index in den Nodestrukturobjekten müssen immer in editimg und controlBox übereinstimmen. Über diesen maßgeblichen index kann auf das Element in der jeweiligen Elementliste zugegriffen und die zugehörige Layer kann zugeordnet werden.

\subsection{Hinzufügen von Elementen}
Jedes Element hat seine separate Funktion zur Platzierung auf der Seite. Innerhalb dieser Funktion wird createStackLayer aufgerufen, um eine Layer mit dem Element zu verknüpfen. Am Ende des Funktionsbodies der Platzierungsoperation wird das Nodestrukturobjekt der zugehörigen Elementliste hinzugefügt. Soll Text ergänzt werden, so wird er in Form des Eigenschaftsobjekts currentUserText erstellt. Alle Eigenschaftsobjekte werden im Nodestukturobjekt property elementToControl verknüpft. Aus Sicht der Implementierung wird bei der Texterstellung ein PDF-Dokument mit einer Seite durch eine PDF-LIB-Funkton erzeugt, auf die der Text an der Klickposition gesetzt wird. Die einzelne PDF-Seite hat die Größe des render\_contexts bzw. der write\_layer. Folglich wird diese Seite mit transparentem Hintergrund mittels pdf.js in das editimg gerendert. Das click event ist mit der write\_layer verknüpft. Alle Funktionen zum Hinzufügen von Elementen sind ebenfalls durch click events an die write\_layer gebunden. In die PDF-Seite wird der Standard-Font TimesRoman eingebettet. Im Eigenschaftsstrukturobjekt befindet sich die PDF-LIB-Funktion drawText. Sie wird in addText mit Standardwerten gefüttert. Zu beachten ist, dass currentUserText.opacity nicht an drawText übergeben wird, da die opacity-Implementierung von Text und Images in der PDF-LIB defekt zu sein scheint. Ich habe die opacity eigenständig implementiert. Das PDFDocument wird in currentUserText.pdfDoc abgelegt und die Uint8Array-Repräsentation in currentUserText.pdfBytes. Die Seitenzahl der write\_layer wird in currentUserText.page festgehalten und die currentUserText.rotation mit 0 initialisiert. Alle Editorelemente werden bei Erzeugung mit einer Rotation von 0 erstellt und alle Eigenschaftsobjekte haben ein page property und x und y properties für die Koordinaten auf der Seite. Des Weiteren wird der Textinhalt als String in currentUserText.text sowie das PDF-LIB-Objekt PDFFont, das beim Einbetten des Fonts entsteht (generisches Promise vom Typ PDFFont), in currentUserText.font und seine ArrayBuffer-Variante in currentUserText.fontKey vermerkt. ArrayBuffer repräsentiert einen generic raw binary data buffer. Text-Eigenschaftsobjekte sind die einzigen Eigenschaftsobjekte mit den properties size für die font size und text, welches den Textinhalt als String protokolliert.
\par
Die Funktion addImage ähnelt addText. Das Image wird ebenfalls auf eine PDF-Seite platziert und mit transparentem Hintergrund in editimg gerendert. Im Vorgang wird das eingelesene Image, welches in der Bilddateiliste in Tools ausgewählt wurde in Form eines DataURLs in das einseitige PDF eingebettet. Ein DataURL besteht teilweise aus einem Base64-encodierten String. Zurückgegeben wird ein Objekt von PDF-LIB als Promise, welches im resolve-Fall eine PDFImage liefert. Das PDFImage wird in currentUserImage.image abgelegt. Das erzeugte PDF-Objekt wird in currentUserImage.pdfDoc und das DataURL-Image in currentUserImage.base64String gespeichert. Shape- und Image-Eigenschaftsobjekte haben width und height properties. In currentUserImage befindet sich die setImageElem-Methode mit der drawImage-PDF-LIB-Funktion.
\par
Shapes und Drawings benötigen keine PDF-Dokumentseite bei ihrer Entstehung. Der shapeControllerP besitzt zusätzliche properties rotation, originX, originY und die Methode rotateControlPoint, um die controlBox gemäß des Shapes im gleichen Winkel zu drehen. In der Funktion addShape wird der Shape direkt auf das editimg durch CANVAS-Methoden für Rechtecke und Ellipsen gezeichnet. Dreiecke müssen aus einzelnen Linien konstruiert werden. In currentShape.context wird der 2D-Rendering-Context der CANVAS referenziert. Er wird für die Zeichenoperationen benötigt. CurrentShape.type speichert den Shapetyp (rectangle, triangle und circle) als String. Die properties xp2 und yp2 bezeichnen den 3. Punkt des Dreiecks (Triangle's 3rd Point). Sie werden ausschließlich bei Erstellung von Triangles initialisiert und bei der Triangle's 3rd Point-Operation angewendet. CurrentShape besitzt die Attribute stroke, strokeWidth, fill, useFill und useStroke. UseFill und useStroke werden für die Steuerung der checkboxes in der GUI bei Stroke Color und Fill Color in Tools verwendet. Entweder kann nur die Stroke Color oder Fill Color anwendet werden oder beide Color-Operationen simultan. 
\par 
Die Funktion zum Hinzufügen von Drawings nennt sich draw und ist mit den mousedown, mousemove und mouseup events auf den write\_layers verbunden. Im drawLayer.paths-Array werden die Pfadpunkte des Zeichenvorgangs gesammelt. Ein Pfadpunkt besteht aus einem Objekt mit den properties:  x, y, line, color und compositeOp. Zuerst wird geprüft, ob sich auf der Seite schon ein Drawing befindet, falls nicht, werden ein controlP und eine drawingLayer erstellt. Sie werden ebenfalls bei Betätigung von New Layer erzeugt. Gezeichnet wird auf der selektierten Layer. Falls keine drawingLayer selektiert ist, wird standardmäßig auf der zuletzt gezeichneten Layer der Seite gemalt. Bei Erstellung der Pfadsegmente wird direkt auf dem context des editimgs gezeichnet. DrawingLayer.currentPathIndex dient der Traversierung von paths. Der Linienstil hat folgende Eigenschaften: Context.lineCap round und context.lineJoin round. Die context.globalCompositeOperation ist als source-over definiert. Im Eraser-Modus ist die globalCompositeOperation auf destination-out festgelegt. Die erase-Funktion arbeitet ähnlich wie draw, nur dass keine Layers, controlPs und drawingLayers erstellt werden. 

\subsection{Erzeugung von Layers}
Die passende Layer zum Element wird in der Erstellungsmethode des Elements addText (Text), addShape (Shape), addImage (Image) oder draw (Drawing) erzeugt. Dort wird die Funktion  createStackLayer aufgerufen. Initial ist die Layer nicht ausgewählt und ungesperrt. Dieser Zustand wird durch die Klassen layer\_unselected und unlocked signalisiert. Die Klassen werden einem DIV mit der Klasse layercontainer hinzugefügt. Layercontainer hat außerdem die Attribute data-page, data-index und data-type. Data-page entspricht der zugehörigen Seitenzahl, data-index dem Index der Elementliste und data-type kann entweder text, drawing, shape oder image sein. Alle verschachtelten child HTML-Elemente im layercontainer sind mit den gleichen data-Attributen versehen. In createStackLayer werden event listener an HTML-Elemente von layercontainer gebunden. Die checkbox ist mit einer Funktion hideLayer und einem input event verknüpft. Das INPUT-HTML-Element mit der Klasse layername für den editierbaren Layernamen hört auf die Funktion markLayer mit einem click event. Das DIV mit der Id layer\_stack\_con wird mit einer Funktion moveLayer verknüpft, die dragstart, dragover und drop events enthält. Dadurch können Layers in ihrer Reihenfolge verändert werden, was bewirkt, dass Editorelemente Richtung Vordergrund bzw. Hintergrund verschoben werden. Außerdem wird die neu erzeugte Layer automatisch in Rosa markiert. Abbildung \ref{fig:layer-stack} zeigt den Aufbau der HTML-Elemente des äußersten layer\_stack-Containers.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=1\textwidth]{"images/layer-stack.png"}
	\caption{Node Tree Segment für den Aufbau der Layers}
	\label{fig:layer-stack}
\end{figure}

Während des Kopiervorgangs von Layers, der durch die Funktion dublicateLayerByElement hervorrufen wird, wird zunächst die Layer per cloneNode(true) dupliziert und erhält einen inkrementierten Index in seinen data-index Attributen. Das zugehörige duplizierte Element erlangt selbigen Index. Die duplizierte Layer wird hinter der source Layer im layer\_stack eingefügt. Folglich liegt das kopierte Element auf dem source Element in der z-Achsenreihenfolge. Außerdem wird der kopierten Layer ein input event mit der hideLayer-Funktion und ein click event mit der markLayer-Funktion angeheftet. Zusätzlich wird erneut moveLayer auf dem layer\_stack\_con ausgeführt, damit die drag events auf der neuen Layer aktualisiert werden. Die Funktion dublicateElement kopiert das Element der duplizierten Layer. In diesem Prozess wird das Nodestrukturobjekt aus seiner Liste geholt und anhand dessen Vorlage ein neues Nodestrukturobjekt, samt Eigenschaftsobjekt, erzeugt. Dessen properties werden mit den Werten der source Objekte initialisiert. Bei kopierten drawingLayer-Objekten ist zu beachten, dass das Objekt mit der deepCopy-Funktion nicht nur die Referenzen kopiert, sondern tatsächlich das Objekt und alle Unterobjekte in paths. Das kopierte Objekt wird seiner Elementliste hinzugefügt und die source Layer bleibt ausgewählt, während die kopierte Layer abgewählt ist. Locked und kopierte Objekte behalten ihren locked-Status.

\subsection{Box Mode Modi}
Bei jeder Operation auf einem Element im Operations Bar und Tools, außer bei den Operationen zum Hinzufügen von Elementen, wird zunächst geprüft, ob der Editor im Box Mode oder Layer Mode arbeitet, und ob die Layer locked ist. Alle Operationen im Box Mode besitzen einen operationseigenen Modus. Jeder Modus wird mit seinem Boolean-Wert in einem Modi-Array protokolliert. Die Modusliste für Operationen auf Text heißt userModes, für Drawings userModesDrawer, für Shapes userModesGeometry und für Images userModesImages. Bei den meisten Buttons im Reader und Editor wird eine Funktion resetAllModes ausgeführt. Sie setzt alle Modilistenbestandteile auf false. Dadurch kann ein vorheriger Operationsmodus verlassen werden. Durch die Ausführung einer neuen Operation, wird ihr Modus aktiviert.

\subsection{Zoomfunktionalität}
Die Zoom-Operationen werden mit einer Verzögerung von 300 ms ausgeführt. Erfolgen Zoom-Operationen zu schnell hintereinander, wird ohne diese Verzögerung ein Fehler geworfen. Der Fehler warnt, dass nicht gleichzeitige Renderoperationen in derselben CANVAS ausgeführt werden können. Im Verlauf der Funktionen zoomIn, zoomOut und enterZoomFactor wird zunächst eine Funktion placeEditorElements aufgerufen, die die controlBoxes und Editorelemente passend zum Zoomfaktor auf der Seite platziert. ControlBoxes behalten beim Zoomen ihre Größe bei. Abschließend werden alle Seiten mit dem neuen Zoomfaktor gerendert.

\subsection{Downloadfunktion}
Die Downloadfunktion für Editorelemente wird in einer promise chain ausgeführt. Zunächst wird der aktuelle Zoomfaktor gespeichert und das PDF-Dokument wird auf 500 \% Prozent im Editor vergrößert. Das hat den Hintergrund, dass alle Editorelemente anschließend als DataURL in Form eines PNG-Bildes in das PDF mit originalPDFBytes eingebettet werden. Genauer gesagt werden alle editimgs mit der Klasse visible zu einem DataURL konvertiert. Editimgs erhalten die Klasse hidden, wenn Layers im Layers Seitenmenü über die grüne checkbox ausgeblendet wurden. Nach der Einbettung der PNG-Bilder mit 500 \% Skalierung wird die Datei zu einem ZIP-Archiv komprimiert. Dabei entsteht ein Blob-Objekt. Das Archiv wird zu einem ObjectURL umgewandelt und durch ein neu erstelltes Anchor-HTML-Element, was dem Body hinzugefügt wird, gedownloaded. Anschließend wird das Anchror-Element wieder vom Body entfernt und das PDF wird auf die vorherige Skalierung zurückgezoomt. Im nächsten Abschnitt werde ich einige Tests der PDF Web App durchführen, um Funktion und Performance zu erörtern. 